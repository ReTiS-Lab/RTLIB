\hypertarget{classRTSim_1_1Task}{}\section{R\+T\+Sim\+:\+:Task Class Reference}
\label{classRTSim_1_1Task}\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}


{\ttfamily \#include $<$task.\+hpp$>$}



Inheritance diagram for R\+T\+Sim\+:\+:Task\+:
% FIG 0


Collaboration diagram for R\+T\+Sim\+:\+:Task\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
const Instr\+List \& \hyperlink{classRTSim_1_1Task_a39cb1cbb9feac69676969de2e2872379}{get\+Instr\+Queue} ()
\item 
const Instr\+Iterator \& \hyperlink{classRTSim_1_1Task_a32a6b6705e5e64474057154f18621867}{get\+Act\+Instr} ()
\item 
void \hyperlink{classRTSim_1_1Task_a0e845b88958c1daa4a661c7870682d83}{reset\+Instr\+Queue} ()
\item 
\hyperlink{classRTSim_1_1Task_a7db5446f507537c11b533ac92e05afb7}{Task} (Random\+Var $\ast$iat, Tick rdl, Tick ph=0, const std\+::string \&name=\char`\"{}\char`\"{}, long qs=1000, Tick maxC=0)
\item 
virtual \hyperlink{classRTSim_1_1Task_a407e6d6dc7aa42b253c7767231b8343e}{$\sim$\+Task} ()
\item 
virtual void \hyperlink{classRTSim_1_1Task_a20ba7201d13480a1328686666b916c3e}{new\+Run} ()
\item 
virtual void \hyperlink{classRTSim_1_1Task_ad6b6b4f089d9b8cf38baeb3aae3f436c}{end\+Run} ()
\item 
virtual void \hyperlink{classRTSim_1_1Task_acf0a63d51c6a763cff175932239db3c5}{activate} ()
\item 
virtual void \hyperlink{classRTSim_1_1Task_a32a9f34149d023a0acd49b5ec1c5a5bd}{activate} (Tick t)
\item 
void \hyperlink{classRTSim_1_1Task_aeb01f785a2a53a56fb12497894000008}{kill\+Instance} ()  throw (\+Task\+Not\+Active, Task\+Not\+Executing)
\item 
void \hyperlink{classRTSim_1_1Task_ac96883083c212b594a3e8a5165c2ba0e}{kill\+On\+Miss} (bool kill)
\item 
virtual void \hyperlink{classRTSim_1_1Task_a17a1b148a33f6e84e5bcb42c2461b66b}{on\+Instr\+End} ()
\item 
void {\bfseries block} ()\hypertarget{classRTSim_1_1Task_ac45a361f5df1cc2ea183d90caf6b205a}{}\label{classRTSim_1_1Task_ac45a361f5df1cc2ea183d90caf6b205a}

\item 
void {\bfseries unblock} ()\hypertarget{classRTSim_1_1Task_a683d5d50c3f6b5dac76bb5a8b80f44a9}{}\label{classRTSim_1_1Task_a683d5d50c3f6b5dac76bb5a8b80f44a9}

\item 
virtual void \hyperlink{classRTSim_1_1Task_a8aa6d8ad5155e0b4e0cb37ed3e238cec}{set\+Trace} (Trace $\ast$t)
\item 
void \hyperlink{classRTSim_1_1Task_a7ce6f11c6157cb22ba089913a2991512}{add\+Instr} (\hyperlink{classRTSim_1_1Instr}{Instr} $\ast$instr)
\item 
void \hyperlink{classRTSim_1_1Task_a4cc696b080cf82e1008506c3410d39bb}{discard\+Instrs} (bool self\+Destruct=true)
\item 
Tick \hyperlink{classRTSim_1_1Task_a7b2d2aa8e133ebbafba2d80e8c7b6441}{get\+Arrival} () const 
\item 
Tick \hyperlink{classRTSim_1_1Task_aa4720d1ca0cc2096d258bebd7429d23a}{get\+Last\+Arrival} () const 
\item 
Tick \hyperlink{classRTSim_1_1Task_a462029660376afbc004f6c92d7c34127}{get\+Exec\+Time} () const 
\item 
Tick {\bfseries get\+Min\+I\+AT} () const \hypertarget{classRTSim_1_1Task_ac922c04e67ea70b6f2381a0ad81a512e}{}\label{classRTSim_1_1Task_ac922c04e67ea70b6f2381a0ad81a512e}

\item 
virtual Tick {\bfseries get\+Last\+Sched} ()\hypertarget{classRTSim_1_1Task_a070f2b38edff561bf7e513e8766eaa51}{}\label{classRTSim_1_1Task_a070f2b38edff561bf7e513e8766eaa51}

\item 
Random\+Var $\ast$ \hyperlink{classRTSim_1_1Task_ae1aa066bab97f7ae4fddfac5b0bf41ee}{change\+I\+AT} (Random\+Var $\ast$iat)
\item 
virtual void \hyperlink{classRTSim_1_1Task_a9477a7af47247368e05f8f16b0f5a28b}{schedule} ()
\item 
virtual void \hyperlink{classRTSim_1_1Task_a7257e6c1e400ecb13ab70e3dee8880c8}{deschedule} ()
\item 
void \hyperlink{classRTSim_1_1Task_a8688e84e3bd7f04e6f8fcdfbcea84d40}{set\+Kernel} (\hyperlink{classRTSim_1_1AbsKernel}{Abs\+Kernel} $\ast$k)  throw (\+Kern\+Already\+Set)
\item 
\hyperlink{classRTSim_1_1AbsKernel}{Abs\+Kernel} $\ast$ \hyperlink{classRTSim_1_1Task_a3f967017ca8660542a7bda106759a3f2}{get\+Kernel} ()
\item 
virtual bool \hyperlink{classRTSim_1_1Task_ae51323db083ab919a2178e07f36ad07b}{is\+Active} () const 
\item 
virtual bool \hyperlink{classRTSim_1_1Task_a86f17c10176f70984a81ad8b06290ae8}{is\+Executing} () const 
\item 
virtual Tick \hyperlink{classRTSim_1_1Task_aacfe0567a0c1f2cb38827022567e9d4f}{get\+W\+C\+ET} () const 
\item 
Tick \hyperlink{classRTSim_1_1Task_ab495e2185796b06b00059e879be0d350}{get\+Deadline} () const 
\item 
Tick \hyperlink{classRTSim_1_1Task_a4140b594cc4f42c3b9c94b54af800c60}{get\+Rel\+Dline} () const 
\item 
void {\bfseries set\+Rel\+Dline} (const Tick \&dl)\hypertarget{classRTSim_1_1Task_adc68100eef6022e68d1a4d71c2ce6c6b}{}\label{classRTSim_1_1Task_adc68100eef6022e68d1a4d71c2ce6c6b}

\item 
\hyperlink{classRTSim_1_1CPU}{C\+PU} $\ast$ \hyperlink{classRTSim_1_1Task_a2a6ed14fa64a0c16d869532504a20119}{get\+C\+PU} () const 
\item 
\hyperlink{classRTSim_1_1CPU}{C\+PU} $\ast$ \hyperlink{classRTSim_1_1Task_a7345e59f9abdea9ce5e7db09f1cc1777}{get\+Old\+C\+PU} () const 
\item 
void \hyperlink{classRTSim_1_1Task_adf7514e4b8692e09972c299f41f5d399}{insert\+Code} (const string \&code)
\item 
void \hyperlink{classRTSim_1_1Task_a5627d2c5eeda74658f9434c91d72cd76}{set\+Feedback\+Module} (\hyperlink{classRTSim_1_1AbstractFeedbackModule}{Abstract\+Feedback\+Module} $\ast$afm)
\item 
void \hyperlink{classRTSim_1_1Task_ae3668377595483e96d123e5dc0bb05be}{print\+Instr\+List} () const 
\item 
void \hyperlink{classRTSim_1_1Task_a5d1ceb465d71ed07ed1f7047c685a86f}{refresh\+Exec} (double old\+Speed, double new\+Speed)
\item 
int \hyperlink{classRTSim_1_1Task_a06fa9011b893f338fd385f0d0ac4c5ad}{get\+Task\+Number} () const 
\item 
void {\bfseries set\+Abort} (bool f)\hypertarget{classRTSim_1_1Task_a562e4a8a1c5b13bc3f1cbfb670c1facc}{}\label{classRTSim_1_1Task_a562e4a8a1c5b13bc3f1cbfb670c1facc}

\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classRTSim_1_1Task}{Task} $\ast$ \hyperlink{classRTSim_1_1Task_a58f3f4be461cc1347f60892675326b88}{create\+Instance} (vector$<$ string $>$ \&par)
\end{DoxyCompactItemize}
\subsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRTSim_1_1ArrEvt}{Arr\+Evt} {\bfseries arr\+Evt}\hypertarget{classRTSim_1_1Task_a23466c1947d46a0bd6e4f602ff2ea209}{}\label{classRTSim_1_1Task_a23466c1947d46a0bd6e4f602ff2ea209}

\item 
\hyperlink{classRTSim_1_1EndEvt}{End\+Evt} {\bfseries end\+Evt}\hypertarget{classRTSim_1_1Task_a80b42caf7fec71180433321d1f7899fb}{}\label{classRTSim_1_1Task_a80b42caf7fec71180433321d1f7899fb}

\item 
\hyperlink{classRTSim_1_1SchedEvt}{Sched\+Evt} {\bfseries sched\+Evt}\hypertarget{classRTSim_1_1Task_a7d241ee11ec1b49e31da028238d26133}{}\label{classRTSim_1_1Task_a7d241ee11ec1b49e31da028238d26133}

\item 
\hyperlink{classRTSim_1_1DeschedEvt}{Desched\+Evt} {\bfseries desched\+Evt}\hypertarget{classRTSim_1_1Task_a465061168fb43b65122da9adabec47fb}{}\label{classRTSim_1_1Task_a465061168fb43b65122da9adabec47fb}

\item 
\hyperlink{classRTSim_1_1FakeArrEvt}{Fake\+Arr\+Evt} {\bfseries fake\+Arr\+Evt}\hypertarget{classRTSim_1_1Task_a3a565a492844186590398ce81b354fa8}{}\label{classRTSim_1_1Task_a3a565a492844186590398ce81b354fa8}

\item 
\hyperlink{classRTSim_1_1KillEvt}{Kill\+Evt} {\bfseries kill\+Evt}\hypertarget{classRTSim_1_1Task_a36198ed8f16c8e3f8551fe5660b57d17}{}\label{classRTSim_1_1Task_a36198ed8f16c8e3f8551fe5660b57d17}

\item 
\hyperlink{classRTSim_1_1DeadEvt}{Dead\+Evt} {\bfseries dead\+Evt}\hypertarget{classRTSim_1_1Task_a4edd7a64dccc9fe4126664f556785a19}{}\label{classRTSim_1_1Task_a4edd7a64dccc9fe4126664f556785a19}

\end{DoxyCompactItemize}
\subsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ \hyperlink{classRTSim_1_1Instr}{Instr} $\ast$ $>$ {\bfseries Instr\+List}\hypertarget{classRTSim_1_1Task_a18432efb06bcbd664305aa1fc24b1808}{}\label{classRTSim_1_1Task_a18432efb06bcbd664305aa1fc24b1808}

\item 
typedef std\+::vector$<$ \hyperlink{classRTSim_1_1Instr}{Instr} $\ast$ $>$\+::iterator {\bfseries Instr\+Iterator}\hypertarget{classRTSim_1_1Task_a37840524bc49eda22440fe31ce0a1873}{}\label{classRTSim_1_1Task_a37840524bc49eda22440fe31ce0a1873}

\item 
typedef std\+::vector$<$ \hyperlink{classRTSim_1_1Instr}{Instr} $\ast$ $>$\+::const\+\_\+iterator {\bfseries Const\+Instr\+Iterator}\hypertarget{classRTSim_1_1Task_a04a42fd1bebba82dae0aa35295b97dfd}{}\label{classRTSim_1_1Task_a04a42fd1bebba82dae0aa35295b97dfd}

\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classRTSim_1_1Task_ad0a923ebab41a60de56862fe682f12ef}{on\+Arrival} (Meta\+Sim\+::\+Event $\ast$)
\item 
void \hyperlink{classRTSim_1_1Task_a45c6a4336341c17beaba74179b168aee}{on\+End\+Instance} (Meta\+Sim\+::\+Event $\ast$)
\item 
void \hyperlink{classRTSim_1_1Task_a289ac955cd726ce9e586dc597716a07f}{on\+Kill} (Meta\+Sim\+::\+Event $\ast$)
\item 
void \hyperlink{classRTSim_1_1Task_a53445a7658aafbfc196b5b1606d6c164}{on\+Sched} (Meta\+Sim\+::\+Event $\ast$)
\item 
void \hyperlink{classRTSim_1_1Task_a9ffde13b8c973b567a9944b6afd11088}{on\+Desched} (Meta\+Sim\+::\+Event $\ast$)
\item 
void \hyperlink{classRTSim_1_1Task_aaa8710695a0f6dafa61f5e562f085bb7}{on\+Fake\+Arrival} (Meta\+Sim\+::\+Event $\ast$)
\item 
void \hyperlink{classRTSim_1_1Task_a06c287744e3a83bd1acac7567f60ec30}{reactivate} ()
\item 
virtual void \hyperlink{classRTSim_1_1Task_add22c413ce6d56bd33d7d6391f688658}{handle\+Arrival} (Tick arrival)
\item 
void \hyperlink{classRTSim_1_1Task_a72f9e2424fe1afe2c130c9d99abc84a7}{buff\+Arrival} ()
\item 
void \hyperlink{classRTSim_1_1Task_a8dbe1e0c2e2a529f8cfd42fb44446114}{unbuff\+Arrival} ()
\item 
Tick \hyperlink{classRTSim_1_1Task_ace91a7f999010a82997fcdd440153179}{get\+Buff\+Arrival} ()
\item 
bool \hyperlink{classRTSim_1_1Task_a61f87f30d18a4a83cc886f2a99b483c5}{chk\+Buff\+Arrival} () const 
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
Meta\+Sim\+::\+Random\+Var $\ast$ {\bfseries int\+\_\+time}\hypertarget{classRTSim_1_1Task_a26e592c148e2dd37e9697eba46061b6b}{}\label{classRTSim_1_1Task_a26e592c148e2dd37e9697eba46061b6b}

\item 
Meta\+Sim\+::\+Tick {\bfseries last\+Arrival}\hypertarget{classRTSim_1_1Task_a8ec91265cb3547c5ba9c57e8cdd04e89}{}\label{classRTSim_1_1Task_a8ec91265cb3547c5ba9c57e8cdd04e89}

\item 
Meta\+Sim\+::\+Tick {\bfseries phase}\hypertarget{classRTSim_1_1Task_a12598b238b111ef65183e60a81c0728d}{}\label{classRTSim_1_1Task_a12598b238b111ef65183e60a81c0728d}

\item 
Meta\+Sim\+::\+Tick {\bfseries arrival}\hypertarget{classRTSim_1_1Task_aef16de6c8e85ec32a3b010143510c398}{}\label{classRTSim_1_1Task_aef16de6c8e85ec32a3b010143510c398}

\item 
Meta\+Sim\+::\+Tick {\bfseries execd\+Time}\hypertarget{classRTSim_1_1Task_a7e27d4a014e6c5b3849047e654ee14fb}{}\label{classRTSim_1_1Task_a7e27d4a014e6c5b3849047e654ee14fb}

\item 
Meta\+Sim\+::\+Tick {\bfseries \+\_\+maxC}\hypertarget{classRTSim_1_1Task_a8c8eb3c6e6d142c8d6bc813be8251dc5}{}\label{classRTSim_1_1Task_a8c8eb3c6e6d142c8d6bc813be8251dc5}

\item 
std\+::deque$<$ Meta\+Sim\+::\+Tick $>$ {\bfseries arr\+Queue}\hypertarget{classRTSim_1_1Task_a9f4afc4f8902529efd44e3df28956d29}{}\label{classRTSim_1_1Task_a9f4afc4f8902529efd44e3df28956d29}

\item 
int {\bfseries arr\+Queue\+Size}\hypertarget{classRTSim_1_1Task_a6c9b148a3988b907b31ee02e2c32f978}{}\label{classRTSim_1_1Task_a6c9b148a3988b907b31ee02e2c32f978}

\item 
task\+\_\+state {\bfseries state}\hypertarget{classRTSim_1_1Task_aeb71c01e949aa7394af6630cffe95a8b}{}\label{classRTSim_1_1Task_aeb71c01e949aa7394af6630cffe95a8b}

\item 
Instr\+List {\bfseries instr\+Queue}\hypertarget{classRTSim_1_1Task_a54f07ec9199bc15029d3fdbe9c2cacf5}{}\label{classRTSim_1_1Task_a54f07ec9199bc15029d3fdbe9c2cacf5}

\item 
Instr\+Iterator {\bfseries act\+Instr}\hypertarget{classRTSim_1_1Task_ad6da9a2b9e687c09ce0832538c535d6f}{}\label{classRTSim_1_1Task_ad6da9a2b9e687c09ce0832538c535d6f}

\item 
\hyperlink{classRTSim_1_1AbsKernel}{Abs\+Kernel} $\ast$ {\bfseries \+\_\+kernel}\hypertarget{classRTSim_1_1Task_a0a586617eb50efb891f3dbaf9dbb6d2a}{}\label{classRTSim_1_1Task_a0a586617eb50efb891f3dbaf9dbb6d2a}

\item 
Meta\+Sim\+::\+Tick {\bfseries \+\_\+last\+Sched}\hypertarget{classRTSim_1_1Task_a95c9bfc32d5eb53fa53f213e9354ca31}{}\label{classRTSim_1_1Task_a95c9bfc32d5eb53fa53f213e9354ca31}

\item 
Meta\+Sim\+::\+Tick {\bfseries \+\_\+dl}\hypertarget{classRTSim_1_1Task_a80c1f751243ed3f679122a4d9d4f71ad}{}\label{classRTSim_1_1Task_a80c1f751243ed3f679122a4d9d4f71ad}

\item 
Meta\+Sim\+::\+Tick {\bfseries \+\_\+rdl}\hypertarget{classRTSim_1_1Task_ae256c53952e0de75c102ac7d79bcc6ee}{}\label{classRTSim_1_1Task_ae256c53952e0de75c102ac7d79bcc6ee}

\item 
\hyperlink{classRTSim_1_1AbstractFeedbackModule}{Abstract\+Feedback\+Module} $\ast$ {\bfseries feedback}\hypertarget{classRTSim_1_1Task_a0f7fdbd72206d11c6df70e4bb5b103cc}{}\label{classRTSim_1_1Task_a0f7fdbd72206d11c6df70e4bb5b103cc}

\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class {\bfseries Arr\+Evt}\hypertarget{classRTSim_1_1Task_a1ed299c7ff891fd374a8e1849880f795}{}\label{classRTSim_1_1Task_a1ed299c7ff891fd374a8e1849880f795}

\item 
class {\bfseries End\+Evt}\hypertarget{classRTSim_1_1Task_ae22d2595f36bcda7f3a5db79796b3714}{}\label{classRTSim_1_1Task_ae22d2595f36bcda7f3a5db79796b3714}

\item 
class {\bfseries Kill\+Evt}\hypertarget{classRTSim_1_1Task_a289e3eed6f45878659d5949af1277c62}{}\label{classRTSim_1_1Task_a289e3eed6f45878659d5949af1277c62}

\item 
class {\bfseries Sched\+Evt}\hypertarget{classRTSim_1_1Task_a15eb030d06ba48fb84706976f30018da}{}\label{classRTSim_1_1Task_a15eb030d06ba48fb84706976f30018da}

\item 
class {\bfseries Desched\+Evt}\hypertarget{classRTSim_1_1Task_a666ee5e2e66781b71061fa9160fee47f}{}\label{classRTSim_1_1Task_a666ee5e2e66781b71061fa9160fee47f}

\item 
class {\bfseries Fake\+Arr\+Evt}\hypertarget{classRTSim_1_1Task_a1e36dee6785de173baede195e3244dc6}{}\label{classRTSim_1_1Task_a1e36dee6785de173baede195e3244dc6}

\item 
class {\bfseries Dline\+Set\+Evt}\hypertarget{classRTSim_1_1Task_a325bd22e8a264067310b294544150f97}{}\label{classRTSim_1_1Task_a325bd22e8a264067310b294544150f97}

\item 
class {\bfseries Dead\+Evt}\hypertarget{classRTSim_1_1Task_ac042a2164b19585b820291848a8b6790}{}\label{classRTSim_1_1Task_ac042a2164b19585b820291848a8b6790}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class models a cyclic task. A cyclic task is a task that is cyclically activated by a timer (for example a periodic task) or by an external event (sporadic or aperiodic task).

This class models a \char`\"{}run-\/to-\/completion\char`\"{} semantic. Every activation (also called arrival), an instance of the task is executed. The task executes all the instructions in the sequence until the last one, and then the instance is completed (task end). At the next activation, the task starts executing a new instance, and the instruction pointer is reset to the beginning of the sequence.

Also\+:


\begin{DoxyItemize}
\item when a job arrives, the corresponding deadline is set (the class \hyperlink{classRTSim_1_1Task}{Task} has no deadline parameter).
\item it adds a deadline event to check deadline misses; it can abort the simulation in case of deadline miss (depending on the abort parameter in the constructor). 
\end{DoxyItemize}

\subsection{Constructor \& Destructor Documentation}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!Task@{Task}}
\index{Task@{Task}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{Task(\+Random\+Var $\ast$iat, Tick rdl, Tick ph=0, const std\+::string \&name="""", long qs=1000, Tick max\+C=0)}{Task(RandomVar *iat, Tick rdl, Tick ph=0, const std::string &name="", long qs=1000, Tick maxC=0)}}]{\setlength{\rightskip}{0pt plus 5cm}R\+T\+Sim\+::\+Task\+::\+Task (
\begin{DoxyParamCaption}
\item[{Random\+Var $\ast$}]{iat, }
\item[{Tick}]{rdl, }
\item[{Tick}]{ph = {\ttfamily 0}, }
\item[{const std\+::string \&}]{name = {\ttfamily \char`\"{}\char`\"{}}, }
\item[{long}]{qs = {\ttfamily 1000}, }
\item[{Tick}]{maxC = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_a7db5446f507537c11b533ac92e05afb7}{}\label{classRTSim_1_1Task_a7db5446f507537c11b533ac92e05afb7}
Constructor.


\begin{DoxyParams}{Parameters}
{\em iat} & Random variable that models activation events. If this parameter is set equal to N\+U\+LL (or 0), then the task is N\+OT cyclically activated. In other words, there is no arrival event automatically posted, but the task must be activated by another entity (task or interrupt, or else). \\
\hline
{\em ph} & initial time of the activation. It is the first time at which the arrival event is posted. This parameter is ignored when iat = 0. \\
\hline
{\em name} & Unique name for this entity.\\
\hline
{\em qs} & Maximum size of the arrival buffer. This is the maximum number of arrivals that can be buffered. By default, this is equal to {\bfseries L\+O\+N\+G\+\_\+\+M\+AX}. If equal to zero, an arrival event is discarded when the task is already active.\\
\hline
{\em maxC} & Worst-\/case execution time of an instance. This parameter is not used for the simulation itself, but only for some algorithm, or for analysis). See \hyperlink{classRTSim_1_1Task_aacfe0567a0c1f2cb38827022567e9d4f}{get\+W\+C\+E\+T()}. \\
\hline
\end{DoxyParams}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!````~Task@{$\sim$\+Task}}
\index{````~Task@{$\sim$\+Task}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{$\sim$\+Task()}{~Task()}}]{\setlength{\rightskip}{0pt plus 5cm}R\+T\+Sim\+::\+Task\+::$\sim$\+Task (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a407e6d6dc7aa42b253c7767231b8343e}{}\label{classRTSim_1_1Task_a407e6d6dc7aa42b253c7767231b8343e}
Virtual destructor. Does nothing.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000019}{Todo}]should it destroy the instructions? probably the answer is Y\+ES. \end{DoxyRefDesc}


\subsection{Member Function Documentation}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!activate@{activate}}
\index{activate@{activate}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{activate()}{activate()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::activate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_acf0a63d51c6a763cff175932239db3c5}{}\label{classRTSim_1_1Task_acf0a63d51c6a763cff175932239db3c5}
This functions activates the tasks (post the arrival event at the current time). 

Implements \hyperlink{classRTSim_1_1AbsTask_a87173c992932ab414d9c993c022d6423}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!activate@{activate}}
\index{activate@{activate}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{activate(\+Tick t)}{activate(Tick t)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::activate (
\begin{DoxyParamCaption}
\item[{Tick}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a32a9f34149d023a0acd49b5ec1c5a5bd}{}\label{classRTSim_1_1Task_a32a9f34149d023a0acd49b5ec1c5a5bd}
This method is used to activate the task (posts the arrival event at the time specified in the parameter)


\begin{DoxyParams}{Parameters}
{\em t} & time of the arrival event\\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000020}{Todo}]what if the task is active? what if the time is in the past? what if the arrival event is already posted? \end{DoxyRefDesc}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!add\+Instr@{add\+Instr}}
\index{add\+Instr@{add\+Instr}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{add\+Instr(\+Instr $\ast$instr)}{addInstr(Instr *instr)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::add\+Instr (
\begin{DoxyParamCaption}
\item[{{\bf Instr} $\ast$}]{instr}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_a7ce6f11c6157cb22ba089913a2991512}{}\label{classRTSim_1_1Task_a7ce6f11c6157cb22ba089913a2991512}
Adds a new instruction at the end of the instruction list. This method has to be invoked during initialization to specify the list of instructions for a task.

The instructions created and added in this way must be destroyed by the \hyperlink{classRTSim_1_1Task}{Task} destructor. Therefore, the owner of the object pointed by instr is the task. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!buff\+Arrival@{buff\+Arrival}}
\index{buff\+Arrival@{buff\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{buff\+Arrival()}{buffArrival()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::buff\+Arrival (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a72f9e2424fe1afe2c130c9d99abc84a7}{}\label{classRTSim_1_1Task_a72f9e2424fe1afe2c130c9d99abc84a7}
handles buffered arrivals\+: inserts an arrival in the buffer \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!change\+I\+AT@{change\+I\+AT}}
\index{change\+I\+AT@{change\+I\+AT}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{change\+I\+A\+T(\+Random\+Var $\ast$iat)}{changeIAT(RandomVar *iat)}}]{\setlength{\rightskip}{0pt plus 5cm}Random\+Var $\ast$ R\+T\+Sim\+::\+Task\+::change\+I\+AT (
\begin{DoxyParamCaption}
\item[{Random\+Var $\ast$}]{iat}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_ae1aa066bab97f7ae4fddfac5b0bf41ee}{}\label{classRTSim_1_1Task_ae1aa066bab97f7ae4fddfac5b0bf41ee}
Change the interarrival time. Used to change the period or the arrival characteristics of the task.


\begin{DoxyParams}{Parameters}
{\em iat} & a random variable that describes the arrival pattern for this cyclic task.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pointer to the old variable random variable
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000022}{Todo}]what happens to the existing iat variable? probably to be changed\+: the task is the owner of the variable, so it should be responsible for deletion. Therefore, we would simply return the period or minimum interarrival time, or just a copy of the random variable with another function. This function should not return anything. \end{DoxyRefDesc}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!chk\+Buff\+Arrival@{chk\+Buff\+Arrival}}
\index{chk\+Buff\+Arrival@{chk\+Buff\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{chk\+Buff\+Arrival() const }{chkBuffArrival() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+T\+Sim\+::\+Task\+::chk\+Buff\+Arrival (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a61f87f30d18a4a83cc886f2a99b483c5}{}\label{classRTSim_1_1Task_a61f87f30d18a4a83cc886f2a99b483c5}
handles buffered arrivals\+: returns true if there is a buffered arrival \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!create\+Instance@{create\+Instance}}
\index{create\+Instance@{create\+Instance}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{create\+Instance(vector$<$ string $>$ \&par)}{createInstance(vector< string > &par)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Task} $\ast$ R\+T\+Sim\+::\+Task\+::create\+Instance (
\begin{DoxyParamCaption}
\item[{vector$<$ string $>$ \&}]{par}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classRTSim_1_1Task_a58f3f4be461cc1347f60892675326b88}{}\label{classRTSim_1_1Task_a58f3f4be461cc1347f60892675326b88}
For the abstract factory \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!deschedule@{deschedule}}
\index{deschedule@{deschedule}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{deschedule()}{deschedule()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::deschedule (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a7257e6c1e400ecb13ab70e3dee8880c8}{}\label{classRTSim_1_1Task_a7257e6c1e400ecb13ab70e3dee8880c8}
From \hyperlink{classRTSim_1_1AbsTask}{Abs\+Task} interface...

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000024}{Todo}]check if it calls the desched\+Evt.\+process()... \end{DoxyRefDesc}


Implements \hyperlink{classRTSim_1_1AbsTask_acbfd410d6c4bd7167aad07d9ca765ff0}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!discard\+Instrs@{discard\+Instrs}}
\index{discard\+Instrs@{discard\+Instrs}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{discard\+Instrs(bool self\+Destruct=true)}{discardInstrs(bool selfDestruct=true)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::discard\+Instrs (
\begin{DoxyParamCaption}
\item[{bool}]{self\+Destruct = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_a4cc696b080cf82e1008506c3410d39bb}{}\label{classRTSim_1_1Task_a4cc696b080cf82e1008506c3410d39bb}
Removes an instruction from the instruction list. This method is invoked mainly during destruction of the task. Removes all instructions. This method removes all instructions from the instruction list.


\begin{DoxyParams}{Parameters}
{\em self\+Destruct} & when this is true (by default is false), the insctructions are destroyed (deallocated). This method is invoked during the destruction of the task. \\
\hline
\end{DoxyParams}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!end\+Run@{end\+Run}}
\index{end\+Run@{end\+Run}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{end\+Run()}{endRun()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::end\+Run (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_ad6b6b4f089d9b8cf38baeb3aae3f436c}{}\label{classRTSim_1_1Task_ad6b6b4f089d9b8cf38baeb3aae3f436c}
Does nothing. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Act\+Instr@{get\+Act\+Instr}}
\index{get\+Act\+Instr@{get\+Act\+Instr}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Act\+Instr()}{getActInstr()}}]{\setlength{\rightskip}{0pt plus 5cm}const Instr\+Iterator\& R\+T\+Sim\+::\+Task\+::get\+Act\+Instr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classRTSim_1_1Task_a32a6b6705e5e64474057154f18621867}{}\label{classRTSim_1_1Task_a32a6b6705e5e64474057154f18621867}
Returns a constant reference to the actual instruction (act\+Instr) \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Arrival@{get\+Arrival}}
\index{get\+Arrival@{get\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Arrival() const }{getArrival() const }}]{\setlength{\rightskip}{0pt plus 5cm}Tick R\+T\+Sim\+::\+Task\+::get\+Arrival (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a7b2d2aa8e133ebbafba2d80e8c7b6441}{}\label{classRTSim_1_1Task_a7b2d2aa8e133ebbafba2d80e8c7b6441}
Returns the arrival time of the current instance 

Implements \hyperlink{classRTSim_1_1AbsTask_acac5cb959420770736d3c0fc51ec31c9}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Buff\+Arrival@{get\+Buff\+Arrival}}
\index{get\+Buff\+Arrival@{get\+Buff\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Buff\+Arrival()}{getBuffArrival()}}]{\setlength{\rightskip}{0pt plus 5cm}Tick R\+T\+Sim\+::\+Task\+::get\+Buff\+Arrival (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_ace91a7f999010a82997fcdd440153179}{}\label{classRTSim_1_1Task_ace91a7f999010a82997fcdd440153179}
handles buffered arrivals\+: returns an arrival from the buffer \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+C\+PU@{get\+C\+PU}}
\index{get\+C\+PU@{get\+C\+PU}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+C\+P\+U() const }{getCPU() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf C\+PU} $\ast$ R\+T\+Sim\+::\+Task\+::get\+C\+PU (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classRTSim_1_1Task_a2a6ed14fa64a0c16d869532504a20119}{}\label{classRTSim_1_1Task_a2a6ed14fa64a0c16d869532504a20119}
Returns a pointer to the \hyperlink{classRTSim_1_1CPU}{C\+PU} on which this task is executing. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Deadline@{get\+Deadline}}
\index{get\+Deadline@{get\+Deadline}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Deadline() const }{getDeadline() const }}]{\setlength{\rightskip}{0pt plus 5cm}Tick R\+T\+Sim\+::\+Task\+::get\+Deadline (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_ab495e2185796b06b00059e879be0d350}{}\label{classRTSim_1_1Task_ab495e2185796b06b00059e879be0d350}
returns the task\textquotesingle{}s deadline 

Implements \hyperlink{classRTSim_1_1AbsRTTask_aab87ec425b45e295517c7b98bc9dcee0}{R\+T\+Sim\+::\+Abs\+R\+T\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Exec\+Time@{get\+Exec\+Time}}
\index{get\+Exec\+Time@{get\+Exec\+Time}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Exec\+Time() const }{getExecTime() const }}]{\setlength{\rightskip}{0pt plus 5cm}Tick R\+T\+Sim\+::\+Task\+::get\+Exec\+Time (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classRTSim_1_1Task_a462029660376afbc004f6c92d7c34127}{}\label{classRTSim_1_1Task_a462029660376afbc004f6c92d7c34127}
Returns the executed time of the last (or current) instance \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Instr\+Queue@{get\+Instr\+Queue}}
\index{get\+Instr\+Queue@{get\+Instr\+Queue}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Instr\+Queue()}{getInstrQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}const Instr\+List\& R\+T\+Sim\+::\+Task\+::get\+Instr\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classRTSim_1_1Task_a39cb1cbb9feac69676969de2e2872379}{}\label{classRTSim_1_1Task_a39cb1cbb9feac69676969de2e2872379}
Returns a constant reference to the instruction queue (instr\+Queue) \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Kernel@{get\+Kernel}}
\index{get\+Kernel@{get\+Kernel}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Kernel()}{getKernel()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Abs\+Kernel}$\ast$ R\+T\+Sim\+::\+Task\+::get\+Kernel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a3f967017ca8660542a7bda106759a3f2}{}\label{classRTSim_1_1Task_a3f967017ca8660542a7bda106759a3f2}
Returns the kernel that contains this task. Can return 0 if this taks does not belong to any kernel. 

Implements \hyperlink{classRTSim_1_1AbsTask_a15624c399f3ebe58211cfccf96aafd28}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Last\+Arrival@{get\+Last\+Arrival}}
\index{get\+Last\+Arrival@{get\+Last\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Last\+Arrival() const }{getLastArrival() const }}]{\setlength{\rightskip}{0pt plus 5cm}Tick R\+T\+Sim\+::\+Task\+::get\+Last\+Arrival (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_aa4720d1ca0cc2096d258bebd7429d23a}{}\label{classRTSim_1_1Task_aa4720d1ca0cc2096d258bebd7429d23a}
Returns the arrival time of the previous instance 

Implements \hyperlink{classRTSim_1_1AbsTask_ae8034fd96bf9f90d92de12dc15323f14}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Old\+C\+PU@{get\+Old\+C\+PU}}
\index{get\+Old\+C\+PU@{get\+Old\+C\+PU}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Old\+C\+P\+U() const }{getOldCPU() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf C\+PU} $\ast$ R\+T\+Sim\+::\+Task\+::get\+Old\+C\+PU (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classRTSim_1_1Task_a7345e59f9abdea9ce5e7db09f1cc1777}{}\label{classRTSim_1_1Task_a7345e59f9abdea9ce5e7db09f1cc1777}
Returns a pointer to the old \hyperlink{classRTSim_1_1CPU}{C\+PU} on which this task was executing. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Rel\+Dline@{get\+Rel\+Dline}}
\index{get\+Rel\+Dline@{get\+Rel\+Dline}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Rel\+Dline() const }{getRelDline() const }}]{\setlength{\rightskip}{0pt plus 5cm}Tick R\+T\+Sim\+::\+Task\+::get\+Rel\+Dline (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a4140b594cc4f42c3b9c94b54af800c60}{}\label{classRTSim_1_1Task_a4140b594cc4f42c3b9c94b54af800c60}
returns the task\textquotesingle{}s relative deadline 

Implements \hyperlink{classRTSim_1_1AbsRTTask_a735b3ff2f6294459cc55d81f18eb547f}{R\+T\+Sim\+::\+Abs\+R\+T\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+Task\+Number@{get\+Task\+Number}}
\index{get\+Task\+Number@{get\+Task\+Number}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+Task\+Number() const }{getTaskNumber() const }}]{\setlength{\rightskip}{0pt plus 5cm}int R\+T\+Sim\+::\+Task\+::get\+Task\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a06fa9011b893f338fd385f0d0ac4c5ad}{}\label{classRTSim_1_1Task_a06fa9011b893f338fd385f0d0ac4c5ad}
returns the \hyperlink{classRTSim_1_1Task}{Task} ID. 

Implements \hyperlink{classRTSim_1_1AbsRTTask_aefea72d5120dcbf15c6ad93f482e24ba}{R\+T\+Sim\+::\+Abs\+R\+T\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!get\+W\+C\+ET@{get\+W\+C\+ET}}
\index{get\+W\+C\+ET@{get\+W\+C\+ET}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{get\+W\+C\+E\+T() const }{getWCET() const }}]{\setlength{\rightskip}{0pt plus 5cm}Tick R\+T\+Sim\+::\+Task\+::get\+W\+C\+ET (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_aacfe0567a0c1f2cb38827022567e9d4f}{}\label{classRTSim_1_1Task_aacfe0567a0c1f2cb38827022567e9d4f}
Returns the worst-\/case computation time. If the maxC parameter in the constructor has not been set, or if it has been set equal to 0, then this function invokes the \hyperlink{classRTSim_1_1Task_aacfe0567a0c1f2cb38827022567e9d4f}{get\+W\+C\+E\+T()} on every instruction in the instruction list, and sums the number togheter. If maxC has been set to a number different from 0, then this function returns maxC. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!handle\+Arrival@{handle\+Arrival}}
\index{handle\+Arrival@{handle\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{handle\+Arrival(\+Tick arrival)}{handleArrival(Tick arrival)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::handle\+Arrival (
\begin{DoxyParamCaption}
\item[{Tick}]{arrival}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_add22c413ce6d56bd33d7d6391f688658}{}\label{classRTSim_1_1Task_add22c413ce6d56bd33d7d6391f688658}
Handle arrival. This is the true arrival event handler.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000018}{Todo}]simplify the arrival handling, by reducing the number of methods to be invoked. \end{DoxyRefDesc}


Reimplemented in \hyperlink{classRTSim_1_1AVRTask_ad2daf3084278c3f85144a70fdb14178a}{R\+T\+Sim\+::\+A\+V\+R\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!insert\+Code@{insert\+Code}}
\index{insert\+Code@{insert\+Code}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{insert\+Code(const string \&code)}{insertCode(const string &code)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::insert\+Code (
\begin{DoxyParamCaption}
\item[{const string \&}]{code}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_adf7514e4b8692e09972c299f41f5d399}{}\label{classRTSim_1_1Task_adf7514e4b8692e09972c299f41f5d399}
Parse and insert instructions into this task. The input string must be a sequence of instructions separated by a semicolon. Last instruction must also end with a semicolon. The instruction can be one of the following\+:


\begin{DoxyItemize}
\item fixed(n) takes an integer number and generates an instruction with fixed computation time;
\item delay(var) takes a random variable and generates a \hyperlink{classRTSim_1_1ExecInstr}{Exec\+Instr} instruction with variable execution time, according to the specified random variable;
\item wait(r) or lock(r) takes a string r containing the name of a resource and produces a \hyperlink{classRTSim_1_1WaitInstr}{Wait\+Instr} on that resource;
\item signal(r) or unlock(r) takes a string r containing the name of a resource and produces a \hyperlink{classRTSim_1_1SignalInstr}{Signal\+Instr} on that resource;
\item activate(t) takes a string containing the name of a task and generates an Activate\+Instr on that task.
\end{DoxyItemize}

An example of usage is the following\+:


\begin{DoxyCode}
t1.insertCode(\textcolor{stringliteral}{"fixed(4);wait(Res1);delay(unif(4,10));}
\textcolor{stringliteral}{signal(Res1); delay(unif(10,20));"});
\end{DoxyCode}


In this case, the task performs 5 instructions; the first one lasts 4 ticks; the second one is a wait on resource Res1; the third one has variable execution time, uniformely distributed between 4 and 10 ticks; the fourth one is a signal on resource Res1; finally, the last instruction has variable execution time uniformely distributed between 10 and 20 ticks. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!is\+Active@{is\+Active}}
\index{is\+Active@{is\+Active}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{is\+Active() const }{isActive() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+T\+Sim\+::\+Task\+::is\+Active (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_ae51323db083ab919a2178e07f36ad07b}{}\label{classRTSim_1_1Task_ae51323db083ab919a2178e07f36ad07b}
Returns true if the task is active. 

Implements \hyperlink{classRTSim_1_1AbsTask_a44e440b2b00cec3c45194de0e554f751}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!is\+Executing@{is\+Executing}}
\index{is\+Executing@{is\+Executing}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{is\+Executing() const }{isExecuting() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+T\+Sim\+::\+Task\+::is\+Executing (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a86f17c10176f70984a81ad8b06290ae8}{}\label{classRTSim_1_1Task_a86f17c10176f70984a81ad8b06290ae8}
Returns true if the task is executing. 

Implements \hyperlink{classRTSim_1_1AbsTask_a91efc74f184aa7b0331c5bb1c8ebd12c}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!kill\+Instance@{kill\+Instance}}
\index{kill\+Instance@{kill\+Instance}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{kill\+Instance()}{killInstance()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::kill\+Instance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) throw  {\bf Task\+Not\+Active}, {\bf Task\+Not\+Executing}) }\hypertarget{classRTSim_1_1Task_aeb01f785a2a53a56fb12497894000008}{}\label{classRTSim_1_1Task_aeb01f785a2a53a56fb12497894000008}
This method permits to kill a task instance that is currently executing. The instruction pointer is reset to the first instruction, and the executed time counter is reset to 0. No further event is posted (in particular, the Task\+End\+Evt is not posted).


\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classRTSim_1_1TaskNotActive}{Task\+Not\+Active}} & if the task is not currently active \\
\hline
{\em \hyperlink{classRTSim_1_1TaskNotExecuting}{Task\+Not\+Executing}} & if the task is not executing\\
\hline
\end{DoxyExceptions}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000021}{Todo}]the last throws is quite suspect.... \end{DoxyRefDesc}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!kill\+On\+Miss@{kill\+On\+Miss}}
\index{kill\+On\+Miss@{kill\+On\+Miss}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{kill\+On\+Miss(bool kill)}{killOnMiss(bool kill)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::kill\+On\+Miss (
\begin{DoxyParamCaption}
\item[{bool}]{kill}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_ac96883083c212b594a3e8a5165c2ba0e}{}\label{classRTSim_1_1Task_ac96883083c212b594a3e8a5165c2ba0e}
This method permits to select the behaviour of the task when a deadline miss occurs.


\begin{DoxyParams}{Parameters}
{\em kill} & = true, to kill the task when a deadline miss occurs \\
\hline
{\em kill} & = false, to contine the task when a deadline miss occurs \\
\hline
\end{DoxyParams}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!new\+Run@{new\+Run}}
\index{new\+Run@{new\+Run}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{new\+Run()}{newRun()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::new\+Run (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a20ba7201d13480a1328686666b916c3e}{}\label{classRTSim_1_1Task_a20ba7201d13480a1328686666b916c3e}
Initializes the internal task structures at the beginning of each run. For example\+:
\begin{DoxyItemize}
\item posts the first arrival event
\item resets the instruction counter
\item resets the executed time counter 
\end{DoxyItemize}

Reimplemented in \hyperlink{classRTSim_1_1AVRTask_af1704bc41d6e891d986f71f40c960b6a}{R\+T\+Sim\+::\+A\+V\+R\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!on\+Arrival@{on\+Arrival}}
\index{on\+Arrival@{on\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{on\+Arrival(\+Meta\+Sim\+::\+Event $\ast$)}{onArrival(MetaSim::Event *)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::on\+Arrival (
\begin{DoxyParamCaption}
\item[{Meta\+Sim\+::\+Event $\ast$}]{e}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_ad0a923ebab41a60de56862fe682f12ef}{}\label{classRTSim_1_1Task_ad0a923ebab41a60de56862fe682f12ef}
This event handler is invoked every time an arrival event is triggered. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!on\+Desched@{on\+Desched}}
\index{on\+Desched@{on\+Desched}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{on\+Desched(\+Meta\+Sim\+::\+Event $\ast$)}{onDesched(MetaSim::Event *)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::on\+Desched (
\begin{DoxyParamCaption}
\item[{Meta\+Sim\+::\+Event $\ast$}]{e}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a9ffde13b8c973b567a9944b6afd11088}{}\label{classRTSim_1_1Task_a9ffde13b8c973b567a9944b6afd11088}
This event handler is invoked everytime the task is suspended by the kernel or by another entity, or it suspends itself. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!on\+End\+Instance@{on\+End\+Instance}}
\index{on\+End\+Instance@{on\+End\+Instance}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{on\+End\+Instance(\+Meta\+Sim\+::\+Event $\ast$)}{onEndInstance(MetaSim::Event *)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::on\+End\+Instance (
\begin{DoxyParamCaption}
\item[{Meta\+Sim\+::\+Event $\ast$}]{e}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a45c6a4336341c17beaba74179b168aee}{}\label{classRTSim_1_1Task_a45c6a4336341c17beaba74179b168aee}
This event handler is invoked when a task completes an instance. It resets the executed time counter, and the instruction counter.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000016}{Todo}]change its name into on\+Instance\+End(). \end{DoxyRefDesc}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!on\+Fake\+Arrival@{on\+Fake\+Arrival}}
\index{on\+Fake\+Arrival@{on\+Fake\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{on\+Fake\+Arrival(\+Meta\+Sim\+::\+Event $\ast$)}{onFakeArrival(MetaSim::Event *)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::on\+Fake\+Arrival (
\begin{DoxyParamCaption}
\item[{Meta\+Sim\+::\+Event $\ast$}]{e}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_aaa8710695a0f6dafa61f5e562f085bb7}{}\label{classRTSim_1_1Task_aaa8710695a0f6dafa61f5e562f085bb7}
This event handler is ivoked everytime a buffered arrival has to be processed. In this case\+:
\begin{DoxyItemize}
\item an arrival event was triggered while the task was still active and was buffered
\item the task has just completed an instance
\item the buffered arrival event is processed
\end{DoxyItemize}

It is used maily for tracing reason (there is not explicit need for an event here). \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!on\+Instr\+End@{on\+Instr\+End}}
\index{on\+Instr\+End@{on\+Instr\+End}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{on\+Instr\+End()}{onInstrEnd()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::on\+Instr\+End (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a17a1b148a33f6e84e5bcb42c2461b66b}{}\label{classRTSim_1_1Task_a17a1b148a33f6e84e5bcb42c2461b66b}
Event propagated by instructions. It is invoked when an instruction is completed. The default behavior is to increment the instruction pointer to the next instrution in the list. If there are no more instrutions, the Task\+End\+Evt is posted at the current time. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!on\+Kill@{on\+Kill}}
\index{on\+Kill@{on\+Kill}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{on\+Kill(\+Meta\+Sim\+::\+Event $\ast$)}{onKill(MetaSim::Event *)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::on\+Kill (
\begin{DoxyParamCaption}
\item[{Meta\+Sim\+::\+Event $\ast$}]{e}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a289ac955cd726ce9e586dc597716a07f}{}\label{classRTSim_1_1Task_a289ac955cd726ce9e586dc597716a07f}
This event handler is invoked when a task instance has been killed. Similar to on\+End\+Instance, but the end\+Evt is not processed. \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!on\+Sched@{on\+Sched}}
\index{on\+Sched@{on\+Sched}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{on\+Sched(\+Meta\+Sim\+::\+Event $\ast$)}{onSched(MetaSim::Event *)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::on\+Sched (
\begin{DoxyParamCaption}
\item[{Meta\+Sim\+::\+Event $\ast$}]{e}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a53445a7658aafbfc196b5b1606d6c164}{}\label{classRTSim_1_1Task_a53445a7658aafbfc196b5b1606d6c164}
This event handler is invoked everytime the task is scheduled (i.\+e. dispatched by the kernel). \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!print\+Instr\+List@{print\+Instr\+List}}
\index{print\+Instr\+List@{print\+Instr\+List}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{print\+Instr\+List() const }{printInstrList() const }}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::print\+Instr\+List (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classRTSim_1_1Task_ae3668377595483e96d123e5dc0bb05be}{}\label{classRTSim_1_1Task_ae3668377595483e96d123e5dc0bb05be}
For debugging reasons. Normally you do not need to call this!

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000025}{Todo}]to be removed eventually. \end{DoxyRefDesc}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!reactivate@{reactivate}}
\index{reactivate@{reactivate}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{reactivate()}{reactivate()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::reactivate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a06c287744e3a83bd1acac7567f60ec30}{}\label{classRTSim_1_1Task_a06c287744e3a83bd1acac7567f60ec30}
Reactivates the task. This method is used to implement a cyclic task. When an arrival event is processed by the \hyperlink{classRTSim_1_1Task_ad0a923ebab41a60de56862fe682f12ef}{on\+Arrival()} event handler, this function is called to post the next arrival event.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000017}{Todo}]re-\/think this function to implement a different kind of task. \end{DoxyRefDesc}
\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!refresh\+Exec@{refresh\+Exec}}
\index{refresh\+Exec@{refresh\+Exec}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{refresh\+Exec(double old\+Speed, double new\+Speed)}{refreshExec(double oldSpeed, double newSpeed)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::refresh\+Exec (
\begin{DoxyParamCaption}
\item[{double}]{old\+Speed, }
\item[{double}]{new\+Speed}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a5d1ceb465d71ed07ed1f7047c685a86f}{}\label{classRTSim_1_1Task_a5d1ceb465d71ed07ed1f7047c685a86f}
Function inherited from \hyperlink{classRTSim_1_1AbsTask}{Abs\+Task}. It refreshes the state of the executing task when a change of the \hyperlink{classRTSim_1_1CPU}{C\+PU} speed occurs.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000026}{Todo}]check which function calls this one. \end{DoxyRefDesc}


Implements \hyperlink{classRTSim_1_1AbsTask_a6ab89d6cc6bfde8ad64ad0b41c4ca64f}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!reset\+Instr\+Queue@{reset\+Instr\+Queue}}
\index{reset\+Instr\+Queue@{reset\+Instr\+Queue}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{reset\+Instr\+Queue()}{resetInstrQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::reset\+Instr\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_a0e845b88958c1daa4a661c7870682d83}{}\label{classRTSim_1_1Task_a0e845b88958c1daa4a661c7870682d83}
Reset the instruction queue pointer\+: act\+Instr = instr\+Queue.\+begin() \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!schedule@{schedule}}
\index{schedule@{schedule}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{schedule()}{schedule()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::schedule (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a9477a7af47247368e05f8f16b0f5a28b}{}\label{classRTSim_1_1Task_a9477a7af47247368e05f8f16b0f5a28b}
From \hyperlink{classRTSim_1_1AbsTask}{Abs\+Task} interface...

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000023}{Todo}]check if it calls the sched\+Evt.\+process()... \end{DoxyRefDesc}


Implements \hyperlink{classRTSim_1_1AbsTask_ab2020522d2d7a046861672af4afc21df}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!set\+Feedback\+Module@{set\+Feedback\+Module}}
\index{set\+Feedback\+Module@{set\+Feedback\+Module}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{set\+Feedback\+Module(\+Abstract\+Feedback\+Module $\ast$afm)}{setFeedbackModule(AbstractFeedbackModule *afm)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::set\+Feedback\+Module (
\begin{DoxyParamCaption}
\item[{{\bf Abstract\+Feedback\+Module} $\ast$}]{afm}
\end{DoxyParamCaption}
)}\hypertarget{classRTSim_1_1Task_a5627d2c5eeda74658f9434c91d72cd76}{}\label{classRTSim_1_1Task_a5627d2c5eeda74658f9434c91d72cd76}
Sets the feedback module for this task (optional, by default no feedback is needed). \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!set\+Kernel@{set\+Kernel}}
\index{set\+Kernel@{set\+Kernel}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{set\+Kernel(\+Abs\+Kernel $\ast$k)}{setKernel(AbsKernel *k)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::set\+Kernel (
\begin{DoxyParamCaption}
\item[{{\bf Abs\+Kernel} $\ast$}]{k}
\end{DoxyParamCaption}
) throw  {\bf Kern\+Already\+Set}) \hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a8688e84e3bd7f04e6f8fcdfbcea84d40}{}\label{classRTSim_1_1Task_a8688e84e3bd7f04e6f8fcdfbcea84d40}
Set the kernel for this task. Called by kernel.\+add\+Task(). If you want to remove a task from a kernel, call this function with k=N\+U\+LL.


\begin{DoxyParams}{Parameters}
{\em k} & pointer to the kernel or 0.\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Kernel\+Already\+Set} & if the user has already set a kernel for this task. To move a task from one kernel to another, call set\+Kernel(0) before. \\
\hline
\end{DoxyExceptions}


Implements \hyperlink{classRTSim_1_1AbsTask_af51d90bc2ae75dfce356abd085c2e3ce}{R\+T\+Sim\+::\+Abs\+Task}.

\index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!set\+Trace@{set\+Trace}}
\index{set\+Trace@{set\+Trace}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{set\+Trace(\+Trace $\ast$t)}{setTrace(Trace *t)}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::set\+Trace (
\begin{DoxyParamCaption}
\item[{Trace $\ast$}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classRTSim_1_1Task_a8aa6d8ad5155e0b4e0cb37ed3e238cec}{}\label{classRTSim_1_1Task_a8aa6d8ad5155e0b4e0cb37ed3e238cec}
Specify that this task has to be traced \index{R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}!unbuff\+Arrival@{unbuff\+Arrival}}
\index{unbuff\+Arrival@{unbuff\+Arrival}!R\+T\+Sim\+::\+Task@{R\+T\+Sim\+::\+Task}}
\subsubsection[{\texorpdfstring{unbuff\+Arrival()}{unbuffArrival()}}]{\setlength{\rightskip}{0pt plus 5cm}void R\+T\+Sim\+::\+Task\+::unbuff\+Arrival (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classRTSim_1_1Task_a8dbe1e0c2e2a529f8cfd42fb44446114}{}\label{classRTSim_1_1Task_a8dbe1e0c2e2a529f8cfd42fb44446114}
handles buffered arrivals\+: removes an arrival from the buffer 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/task.\+hpp\item 
src/task.\+cpp\end{DoxyCompactItemize}
